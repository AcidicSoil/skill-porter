{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Implement Core TOML Parsing and Serialization Utility",
        "description": "Create a shared utility module for parsing and serializing TOML files. This foundational module will wrap a TOML library to provide consistent error handling and a simplified API for all other Codex-related features that interact with .toml files.",
        "details": "Create the file `src/core/toml.ts`. Use a robust, well-maintained library like `@iarna/toml`. The module should export `parseToml<T>(text: string): T` and `stringifyToml(obj: unknown): string`. The `parseToml` function should throw a custom `TomlError` on failure to allow for specific error handling upstream. Ensure the implementation is type-safe. \n\nPseudo-code:\n```typescript\nimport TOML from '@iarna/toml';\n\nexport class TomlError extends Error {}\n\nexport function parseToml<T>(text: string): T {\n  try {\n    return TOML.parse(text) as T;\n  } catch (e) {\n    throw new TomlError(`Failed to parse TOML: ${e.message}`);\n  }\n}\n\nexport function stringifyToml(obj: unknown): string {\n  return TOML.stringify(obj);\n}\n```",
        "testStrategy": "Create unit tests in `tests/core/toml.test.ts`. Test cases should include: successfully parsing a valid TOML string, successfully stringifying a JavaScript object, throwing `TomlError` for syntactically incorrect TOML, and round-trip tests (stringify then parse) to ensure data integrity.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Define Codex Plugin Specification and Schema",
        "description": "Implement the canonical in-memory representation of the Codex plugin specification, including the manifest (`codex-plugin.toml`) and directory layout. This module will be the single source of truth for all Codex-related data structures.",
        "details": "Create the file `src/spec/codexPluginSpec.ts`. Define and export TypeScript types: `CodexPluginManifest`, `CodexCapabilities`, and `CodexPluginLayout`. Implement `parseCodexManifest` which uses the core TOML utility. Implement `validateCodexManifest` to check for required fields (`plugin.id`, `display_name`, etc.) and valid formats (e.g., `id` must be a slug `[a-z0-9-]+`). Implement `defaultCodexLayout` to define the standard file paths within the `codex/` directory.",
        "testStrategy": "Unit test `validateCodexManifest` with various manifest objects: a valid one, one with missing required fields, one with an invalid `id` slug, and one with extra fields. Use snapshot testing for the `defaultCodexLayout` output. Ensure `parseCodexManifest` correctly uses the TOML utility from Task 1.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Extend Platform Detector for Codex Support",
        "description": "Update the existing `PlatformDetector` to recognize Codex artifacts, enabling the CLI to classify repositories as 'codex' or 'universal'. This involves searching for the `codex/codex-plugin.toml` file.",
        "details": "Modify `src/analyzers/platformDetector.ts`. First, create a new analyzer `src/analyzers/codexMetadata.ts` that is responsible for finding and parsing Codex files (`codex-plugin.toml`, `CODEX_AGENTS.md`, etc.). The main `platformDetector.ts` will call this new analyzer. Based on the presence of Codex files alongside existing Claude/Gemini files, the `detectPlatform` function should now be able to return `'codex'` or `'universal'` in addition to the existing platform types. The `analyze` command output should be updated to include a summary of the Codex plugin if detected.",
        "testStrategy": "Create test fixtures representing different repository states: Codex-only, Claude+Codex, Gemini+Codex, and all three (universal). Write unit tests for `platformDetector` that assert the correct platform type is detected for each fixture. Add an integration test for the `analyze` CLI command to verify its output includes the Codex summary.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Codex Artifact Validator",
        "description": "Create a dedicated validator for Codex plugins that checks for correctness beyond basic manifest schema validation. This includes verifying file paths and logical consistency between the manifest and other files.",
        "details": "Create the file `src/validation/codexValidator.ts`. Implement the function `validateCodex(repoRoot, codexMetadata)`. This function should: \n1. Verify that the files referenced in `codex-plugin.toml` (e.g., `agents_file`, `config_snippet_file`) actually exist on disk relative to the plugin root. \n2. Parse the `codex-config.snippet.toml` and check that if `uses_mcp` is true in the manifest, at least one `[mcp_servers.*]` section exists in the snippet. \n3. Emit structured errors for blocking issues and warnings for non-blocking issues. This validator will be integrated into the main `validate` command.",
        "testStrategy": "Use test fixtures with various invalid setups: a manifest pointing to a non-existent `agents_file`, a manifest with `uses_mcp = true` but an empty config snippet, etc. Write unit tests for `codexValidator.ts` that assert the correct errors and warnings are returned for each case. Add integration tests for the main `validate` CLI command to ensure Codex validation results are included in the final report.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Codex Documentation Generator",
        "description": "Create a module responsible for programmatically generating the content for `CODEX_AGENTS.md` and `docs/CODEX_ARCHITECTURE.md` based on skill metadata.",
        "details": "Create the file `src/docs/codexDocsGenerator.ts`. Implement `generateCodexAgentsDoc` which takes context (plugin name, description, MCP server list) and produces a markdown string with a standard structure (H1, summary, 'MCP servers' section). Implement `generateCodexArchitectureDoc` which generates a document explaining the plugin's integration with Codex. Use simple string templates or a lightweight templating engine. The content should be derived from the source skill's metadata and the newly created Codex manifest.",
        "testStrategy": "Use snapshot testing. Create unit tests that call the generator functions with mock context objects and compare the output markdown against stored snapshots. This ensures that changes to the document structure are intentional. Test edge cases like a skill with no MCP servers.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Claude-to-Codex Converter",
        "description": "Create the conversion logic to transform a Claude skill (defined by `SKILL.md` and MCP metadata) into a complete, valid Codex plugin.",
        "details": "Create the file `src/converters/claudeToCodexConverter.ts`. The main function `convertClaudeToCodex` will: \n1. Read and parse the source Claude `SKILL.md` file and its YAML frontmatter. \n2. Map Claude metadata (name, description) to the `CodexPluginManifest` fields. `name` should be slugified for `plugin.id`. \n3. Infer `CodexCapabilities` from `allowed-tools` and MCP server usage. \n4. Use the `codexDocsGenerator` (from Task 5) to create `CODEX_AGENTS.md` and other documentation. \n5. Translate Claude MCP server definitions into `[mcp_servers.*]` blocks in `codex-config.snippet.toml`. \n6. Write all generated files to the `codex/` output directory.",
        "testStrategy": "Use golden file testing. Create a sample Claude skill as a test fixture. Run the converter and compare the entire generated `codex/` directory against a pre-approved 'golden' version stored in the repository. This validates file content, naming, and structure. Ensure the generated artifacts pass the `codexValidator` from Task 4.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Gemini-to-Codex Converter",
        "description": "Create the conversion logic to transform a Gemini extension (defined by `gemini-extension.json` and `GEMINI.md`) into a complete, valid Codex plugin.",
        "details": "Create `src/converters/geminiToCodexConverter.ts`. Similar to the Claude converter, the `convertGeminiToCodex` function will: \n1. Read and parse `gemini-extension.json` and `GEMINI.md`. \n2. Map Gemini metadata (`name`, `description`, `version`) to the `CodexPluginManifest`. \n3. Translate `mcpServers` from the JSON into `[mcp_servers.*]` TOML blocks. \n4. Use `codexDocsGenerator` to generate documentation, stripping Gemini-specific instructions from the source `GEMINI.md`. \n5. Write all generated files to the `codex/` directory.",
        "testStrategy": "Use golden file testing, similar to the Claude converter. Create a sample Gemini extension fixture. Run the converter and assert that the generated `codex/` directory matches a checked-in golden version. Validate the output with `codexValidator` to ensure correctness.",
        "priority": "high",
        "dependencies": [
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Integrate Codex into CLI `convert` Command",
        "description": "Extend the `skill-porter convert` command to support `codex` as a target, route to the correct converter, and print post-conversion instructions for the user.",
        "details": "Modify `src/cli/convertCommand.ts`. Update the command's options to accept `codex` as a valid value for the `--to` flag. In the command handler, detect the source platform (Claude or Gemini) and invoke the corresponding converter (from Task 6 or 7). After a successful conversion, print a formatted, user-friendly message to the console with next steps, including the copy-paste-ready command to append the config snippet to `~/.codex/config.toml`.",
        "testStrategy": "Write CLI integration tests. Use a test runner that can execute the compiled CLI binary. Create temporary directories with sample Claude and Gemini skills. Run `skill-porter convert --to codex` and assert that: \n1. The command exits with a success code. \n2. The `codex/` directory and its files are created correctly. \n3. The console output contains the expected 'Next steps' instructions.",
        "priority": "high",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Extend `universal` Command for Tri-Platform Support",
        "description": "Update the `universal` command to include Codex as a required platform, ensuring a repository has valid artifacts for Claude, Gemini, and Codex.",
        "details": "Modify `src/cli/universalCommand.ts`. The command logic should first run the platform detector. If Codex artifacts are missing, it should invoke the `convert --to codex` logic internally. The command should only exit successfully if artifacts for all three platforms (Claude, Gemini, Codex) are present and pass their respective validation checks. This leverages the work from all previous tasks to create a single, powerful command.",
        "testStrategy": "Create end-to-end tests for the `universal` command. Start with fixtures that are missing one or more platforms (e.g., only Claude, or Claude+Gemini). Run `skill-porter universal` and assert that the missing artifacts (including Codex) are generated. Finally, run the `validate` command and assert that the now-universal repo passes all checks.",
        "priority": "high",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Update Documentation and Create Example Repository",
        "description": "Document the new Codex conversion functionality in the project's README and create a fully-functional example repository that demonstrates a 'universal' skill.",
        "details": "1. Add a 'Codex CLI Support' section to the main `README.md`. This section should explain the `convert --to codex` and `universal` commands, the structure of the `codex/` directory, and provide a quickstart example. \n2. Create a new directory `examples/codex-basic/`. This directory will contain a simple skill with a mock MCP server. It should be fully configured to be 'universal', containing valid Claude, Gemini, and Codex artifacts. This example will be used in automated testing.",
        "testStrategy": "1. Manually review the README for clarity and correctness. \n2. Add a new script to the `package.json` that runs the `skill-porter universal` and `skill-porter validate` commands within the `examples/codex-basic/` directory as part of the CI/test suite. This ensures the example remains correct and functional as the codebase evolves.",
        "priority": "medium",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-12-04T06:46:58.358Z",
      "updated": "2025-12-04T06:46:58.358Z",
      "description": "Tasks for master context"
    }
  }
}