Plan upgraded using the hi-ai workflow you requested.

---

## 1. Targets and Constraints

**Objective**

Extend `skill-porter` so that:

* Codex CLI is a first-class platform alongside Claude Code and Gemini.
* Users can convert Claude/Gemini skills into Codex “plugins”.
* A Codex plugin directory format exists and is generated by `skill-porter`.

**Non-goals**

* No changes to Codex core.
* No bespoke Codex RPC; only file/config-based integration using `config.toml` + `AGENTS.md`.

---

## 2. Workstreams

1. Spec: Codex plugin format (on-disk structure + schema).
2. Core wiring: Platform detection and validation for Codex.
3. Converters: Claude→Codex, Gemini→Codex.
4. CLI & universal flow: new flags, UX messages, “universal” spanning all three CLIs.
5. Docs & examples: user instructions, minimal example repo.
6. Optional: reverse converters (Codex→Claude/Gemini) and helper tooling.

---

## 3. Detailed Task Checklist

Use this as the execution list. No time annotations, just ordering.

### 3.1 Define Codex Plugin Spec

* [ ] Decide plugin directory shape (relative to repo root):

  ```text
  codex/
    codex-plugin.toml
    CODEX_AGENTS.md
    codex-config.snippet.toml
    docs/
      CODEX_ARCHITECTURE.md
  ```

* [ ] Lock `codex-plugin.toml` schema:

  ```toml
  [plugin]
  id = "my-skill"                # slug
  display_name = "My Skill"
  description = "Short text."
  version = "1.0.0"
  homepage = "https://github.com/owner/repo"
  source_repo = "https://github.com/owner/repo"
  license = "MIT"

  agents_file = "CODEX_AGENTS.md"
  config_snippet_file = "codex-config.snippet.toml"

  [plugin.capabilities]
  uses_mcp = true
  reads_files = true
  writes_files = false
  runs_shell = true
  ```

* [ ] Lock `CODEX_AGENTS.md` convention:

  * H1 title with plugin name.
  * Summary paragraph (“Use this agent when…”).
  * Operational guidance derived from Claude/Gemini docs.
  * Explicit “MCP servers” section enumerating expected server names.

* [ ] Lock `codex-config.snippet.toml` conventions:

  * Always gated by an instruction comment `# Append this to ~/.codex/config.toml`.
  * At least one `[mcp_servers.*]` block.
  * Use `env` + `env_vars` for STDIO, `url` + `bearer_token_env_var` + `http_headers` for HTTP.
  * Optional `enabled_tools` / `disabled_tools` when you can infer tool subsets.

* [ ] Decide plugin root location resolution:

  * Default: create `codex/` alongside `.claude/` / `gemini-extension.json`.
  * Make sure paths inside `codex-config.snippet.toml` are relative to repo, not absolute.

### 3.2 Wire Codex into Analyzers

#### PlatformDetector

* [ ] Extend `PLATFORM_TYPES` with `'codex'`.
* [ ] Track Codex-related files: `codex-plugin.toml`, `CODEX_AGENTS.md`, `codex-config.snippet.toml`, any `codex/` subtree.
* [ ] Implement `_detectCodexFiles(dirPath)`:

  * Searches standard locations (root + `codex/`).
  * If `codex-plugin.toml` exists, parse TOML, populate `metadata.codex`:

    * `id`, `display_name`, `description`, `version`, `agents_file`, `config_snippet_file`.
* [ ] Update `detect()` platform decision logic:

  * Only Codex files → `platform = 'codex'`.
  * Any combination of Claude/Gemini/Codex >1 → `platform = 'universal'`.
* [ ] Update `analyze` output to show Codex summary (id, version, file paths).

#### Validator

* [ ] Add `CODEX` branch to `validate()`:

  * Call `_validateCodex()` for `platform === 'codex'` or `'universal'`.
* [ ] Implement `_validateCodex(dirPath)`:

  * Ensure `codex-plugin.toml` present and parseable.
  * Validate required fields: `plugin.id`, `display_name`, `description`, `version`.
  * Validate `id` slug format `[a-z0-9-]+`.
  * Verify `agents_file` and `config_snippet_file` exist, resolve relative paths.
  * Basic sanity on `codex-config.snippet.toml`:

    * At least one `[mcp_servers.*]` table.
    * Warn if `uses_mcp = true` but no servers.
* [ ] Add Codex errors/warnings to existing structured output.

### 3.3 Implement Claude→Codex Converter

* [ ] Introduce `ClaudeToCodexConverter` class parallel to `ClaudeToGeminiConverter`.
* [ ] Input assumptions:

  * `SKILL.md` with YAML frontmatter, existing Claude MCP wiring already interpreted by `skill-porter`.
* [ ] Steps:

  * [ ] Parse `SKILL.md` frontmatter:

    * `name`, `description`, `allowed-tools`, any MCP metadata surfaced by current analyzers.
  * [ ] Generate `codex-plugin.toml`:

    * Map `name` → `plugin.id` (slugified) and `display_name`.
    * Map `description` → `plugin.description`.
    * Derive `capabilities` flags (heuristic based on allowed tools and content).
  * [ ] Generate `CODEX_AGENTS.md`:

    * Title: `# <display_name> – Codex agent instructions`.
    * Summary from description.
    * Body from SKILL.md content minus frontmatter and any Claude-only sections.
    * Append “MCP servers” section using existing MCP metadata.
  * [ ] Generate `codex-config.snippet.toml`:

    * For each known MCP server used by the skill (SkillPorter already knows servers for Claude/Gemini):

      * Map into `[mcp_servers.<name>]` with `command`, `args`, `cwd`, `env`, `env_vars` or `url`/HTTP options.
    * If Claude `allowed-tools` restricts tools, convert to `enabled_tools`/`disabled_tools`.
  * [ ] Generate `docs/CODEX_ARCHITECTURE.md`:

    * Explain high-level: how Codex uses `AGENTS.md`/MCP and how this plugin fits.
  * [ ] Return same result shape as other converters.

### 3.4 Implement Gemini→Codex Converter

* [ ] Introduce `GeminiToCodexConverter`.
* [ ] Input assumptions:

  * `gemini-extension.json`, `GEMINI.md`, `commands/`, `mcpServers` already parsed by existing code.
* [ ] Steps:

  * [ ] Read `gemini-extension.json`:

    * `name`, `description`, `version`, `mcpServers`, `excludeTools`, `settings`.
  * [ ] Generate `codex-plugin.toml`:

    * Map `name` → `plugin.id` and `display_name`.
    * Map `description` and `version`.
    * Capabilities derived from `mcpServers` and settings.
  * [ ] Generate `CODEX_AGENTS.md`:

    * Derive from `GEMINI.md`, removing Gemini CLI specific install sections.
    * Same “MCP servers” section as Claude converter.
  * [ ] Generate `codex-config.snippet.toml`:

    * Translate each `mcpServers` entry to a `[mcp_servers.*]` Codex block.
    * Handle exclusion/inclusion:

      * Use existing tool list inference to compute `enabled_tools` if `excludeTools` is set.
  * [ ] Generate `docs/CODEX_ARCHITECTURE.md`:

    * Explain how Gemini extension concepts map to Codex config.

### 3.5 Hook Converters into SkillPorter

* [ ] Add imports in `src/index.js` for the two new converters.

* [ ] Extend `convert()` routing:

  * If `to === 'codex'`:

    * Claude source → `ClaudeToCodexConverter`.
    * Gemini source → `GeminiToCodexConverter`.
  * Maintain existing routes for `claude` and `gemini`.

* [ ] Ensure error messages list `codex` as an allowed target.

* [ ] Include Codex metadata in diagnostic output (`analyze`, `validate`, `convert --dry-run`).

### 3.6 Extend CLI and “Universal” Flow

* [ ] CLI options:

  * Extend `--to` validation to accept `codex`.
  * Update help text: “claude, gemini, codex”.

* [ ] Success messages:

  * For `--to codex`, print concrete post-steps:

    ```text
    Next steps for Codex:
      1. Append codex/codex-config.snippet.toml to ~/.codex/config.toml
      2. Either:
         - Merge codex/CODEX_AGENTS.md into your AGENTS.md, or
         - Add CODEX_AGENTS.md to project_doc_fallback_filenames in ~/.codex/config.toml
    ```

* [ ] `universal` command:

  * Replace dual-CLAUDE/GEMINI logic with tri-platform logic:

    * If missing Gemini artifacts → run `convert --to gemini`.
    * If missing Claude artifacts → run `convert --to claude`.
    * If missing Codex artifacts → run `convert --to codex`.
  * Final message: universal = Claude + Gemini + Codex.

### 3.7 Docs and Examples

* [ ] Add README section: “Codex CLI Support”.

  * Inputs, outputs, usage, limitations.
* [ ] Create `examples/codex-basic/`:

  * Minimal skill with Claude + Gemini + generated Codex plugin artifacts.
  * Document exact `codex` commands and a working MCP server or mock.
* [ ] If you have `ForkSetup` / `PRGenerator` documentation, update them to reference Codex integration flow.

### 3.8 Optional: Reverse Converters and Helper CLI

#### Reverse Converters

* [ ] Add `CodexToClaudeConverter`:

  * Parse `codex-plugin.toml`, `CODEX_AGENTS.md`, `codex-config.snippet.toml`.
  * Generate `SKILL.md`, `.claude-plugin/marketplace.json`, `.claude/commands/*`.
* [ ] Add `CodexToGeminiConverter`:

  * Same inputs → `gemini-extension.json`, `GEMINI.md`, `commands/*`.

#### `codex-plugins` Helper (separate small tool)

* [ ] Define simple CLI:

  * `codex-plugins install ./codex`:

    * Copy to `~/.codex/plugins/<id>/`.
    * Append `codex-config.snippet.toml` to `~/.codex/config.toml` idempotently.
  * `codex-plugins list`, `remove`, etc.
* [ ] Keep this outside `skill-porter` repo to avoid coupling with Codex internals.

---

## 4. Execution Order

Strict execution sequence for a single developer:

1. Spec:

   * Codex plugin directory layout, TOML schemas, Markdown conventions.
2. Analyzer wiring:

   * Extend `PLATFORM_TYPES`, detection and validation.
3. Converters:

   * Implement Claude→Codex.
   * Implement Gemini→Codex.
4. Integration:

   * Hook converters into `SkillPorter.convert`.
   * Extend CLI and universal flow.
5. Validation:

   * Add tests for detection, validation, and conversion round-trips.
6. Documentation:

   * README updates, example repo, minimal walkthrough.
7. Optional:

   * Reverse converters.
   * Separate `codex-plugins` install helper.

Use the checklist above as the control panel.
