### 0. Outcome

You can turn `skill-porter` into a 3-way bridge: Claude Code ↔ Gemini CLI ↔ Codex CLI.

Concrete result:

* A Codex plugin format modeled on Claude Code’s skills/plugins.
* New `codex` platform in `skill-porter` with converters:

  * `Claude → Codex`
  * `Gemini → Codex`
  * `Codex → Claude` and `Codex → Gemini` (optional but straightforward given the structure below).
* CLI usage stays symmetric: `skill-porter convert ... --to codex` and `skill-porter universal ...` extended to include Codex.

Everything below tells you exactly what to change, where, and how.

---

## 1. Problem Framing (hi-ai “Understand” phase)

You want:

* Same “one repo, many AI CLIs” story that `skill-porter` already gives for Claude Code + Gemini CLI, but including Codex CLI.
* A Codex “plugin system” that feels as natural as Claude Code’s:

  * Folder-based units you can ship and reuse.
  * Clear instructions + MCP wiring.
* Minimal cognitive friction: authors define one skill/extension, the tooling handles the cross-platform wiring.

Existing pieces:

* `skill-porter` already:

  * Detects Claude vs Gemini vs Universal skill dirs via `PlatformDetector` and `PLATFORM_TYPES`.
  * Converts:

    * Claude’s `SKILL.md`, `.claude-plugin/marketplace.json`, `.claude/commands/*.md`
    * Gemini’s `gemini-extension.json`, `GEMINI.md`, `commands/*.toml`
  * Bridges MCP server config between platforms and infers settings/env vars.
* Codex CLI has:

  * Central config in `~/.codex/config.toml`.
  * First-class MCP support under `[mcp_servers.*]`, with STDIO and HTTP transports plus flags like `enabled_tools` / `disabled_tools`. ([GitHub][1])
  * `AGENTS.md` discovery for project-level instructions (with configurable fallback filenames). ([GitHub][1])

Missing piece: a standard on-disk unit for Codex “plugins” that can be generated and consumed automatically.

---

## 2. System Scan (hi-ai “Scan” phase)

### 2.1 Claude Code plugin/skill model

From Anthropic’s docs and repo:

* Skills:

  * `~/.claude/skills/<skill-name>/SKILL.md` with YAML frontmatter (`name`, `description`, `allowed-tools`, optional `subagents`, etc.). ([Claude Docs][2])
* Plugins:

  * `.claude-plugin/marketplace.json` describing plugin metadata + skills bundle.
* Commands:

  * `.claude/commands/*.md` for slash commands.

`skill-porter` knows all of that.

### 2.2 Gemini CLI model (as encoded in `skill-porter`)

* Manifest: `gemini-extension.json` with `name`, `description`, `version`, `settings`, `excludeTools`, `mcpServers`, etc.
* Docs: `GEMINI.md` and `docs/` directory.
* Commands: `commands/*.toml` for Gemini custom commands.
* `skill-porter` already maps:

  * Claude `allowed-tools` ↔ Gemini `excludeTools`.
  * MCP config across both platforms.
  * Documentation between `SKILL.md` and `GEMINI.md`.

### 2.3 Codex CLI integration points

From `config.md`:

* MCP servers live under:

  ````toml
  [mcp_servers.server_name]
  command = "npx"
  args = ["mcp-server"]
  env   = { "API_KEY" = "value" }
  env_vars = ["API_KEY2"]
  cwd   = "/path/to/server"
  # optional: enabled_tools, disabled_tools, startup_timeout_sec, tool_timeout_sec, enabled, ...
  ``` :contentReference[oaicite:8]{index=8}

  ````
* HTTP MCP servers use:

  ````toml
  [mcp_servers.figma]
  url = "https://mcp.figma.com/mcp"
  bearer_token_env_var = "ENV_VAR"
  http_headers = { ... }
  env_http_headers = { ... }
  ``` :contentReference[oaicite:9]{index=9}

  ````
* MCP management via CLI: `codex mcp add/list/get/remove/login/logout`. ([GitHub][1])
* Agent instructions discovered via `AGENTS.md` and optional fallbacks (`project_doc_fallback_filenames`). ([GitHub][1])

Conclusion: Codex doesn’t have “plugins”, but it does have everything a plugin system needs: config snippets + AGENT docs.

---

## 3. Design Hypothesis (hi-ai “Hypothesize” phase)

Build a **Codex Plugin spec** that:

1. Mirrors Claude Skills + Plugins at the directory level.
2. Is purely file-based (no extra daemon), so it can be generated by `skill-porter`.
3. Can be consumed either:

   * Manually (user pastes config into `~/.codex/config.toml`), or
   * By a future `codex-plugins` helper CLI that you or the community can implement.

Then:

* Extend `skill-porter` to treat **Codex** as a first-class platform.
* Implement converters between `claude/gemini` and `codex` based on that spec.
* Keep round-trip safe: no destructive edits to source files; everything goes into plugin-specific files.

---

## 4. Codex Plugin Spec (the thing `skill-porter` will emit)

Define a single plugin directory, intended to live either in the repo or under `~/.codex/plugins`:

```text
my-skill/
  codex-plugin.toml         # plugin metadata + wiring metadata
  CODEX_AGENTS.md           # agent instructions snippet
  codex-config.snippet.toml # drop-in config for ~/.codex/config.toml
  docs/
    CODEX_ARCHITECTURE.md   # same spirit as existing *_ARCHITECTURE docs
  shared/                   # optional, shared docs with Claude/Gemini
```

### 4.1 `codex-plugin.toml`

Minimal schema:

```toml
[plugin]
id = "my-skill"                # slug, lowercase hyphenated
display_name = "My Skill"
description = "Short human description."
version = "1.0.0"
homepage = "https://github.com/owner/repo"
source_repo = "https://github.com/owner/repo"
license = "MIT"

# path to files within the plugin directory
agents_file = "CODEX_AGENTS.md"
config_snippet_file = "codex-config.snippet.toml"

[plugin.capabilities]
# high-level hints (purely descriptive for now)
uses_mcp = true
reads_files = true
writes_files = false
runs_shell = true
```

You can extend this later (tags, categories, etc.) without affecting `skill-porter` core logic.

### 4.2 `CODEX_AGENTS.md`

Content derived from Claude `SKILL.md` or Gemini `GEMINI.md`:

* Header:

  ```markdown
  # my-skill – Codex agent instructions

  Use this agent when the user needs: <description>.
  ```

* A “How Codex should behave” section derived from `SKILL.md` body, Gemini docs, or both.

* An MCP section enumerating the servers the plugin expects:

  ```markdown
  ## MCP servers

  This skill expects Codex to have the following MCP servers configured:

  - `my-skill`: STDIO MCP server for ...
  - `my-skill-http`: HTTP MCP server for ...
  ```

Codex will pick this up if you either:

* Put it in `AGENTS.md` directly, or
* Add `CODEX_AGENTS.md` to `project_doc_fallback_filenames` in `config.toml`. ([GitHub][1])

This is why the filename is distinct: you can either:

* Copy/merge it into `AGENTS.md`, or
* Configure Codex to fall back to `CODEX_AGENTS.md`.

### 4.3 `codex-config.snippet.toml`

This is the key integration piece. Example, for a converted MCP server:

```toml
# Append this to ~/.codex/config.toml

[features]
rmcp_client = true

[mcp_servers.my-skill]
command = "npx"
args = ["my-skill-mcp"]
cwd = "/path/to/repo"          # if relative, resolve at install time
env = { "MY_SKILL_API_KEY" = "${MY_SKILL_API_KEY}" }
env_vars = ["MY_SKILL_API_KEY"]

# Optional: tighten or relax tool exposure
enabled_tools = ["search", "summarize"]
# disabled_tools = ["delete"]

# Optional: timeouts
startup_timeout_sec = 20
tool_timeout_sec = 60
```

For HTTP MCP servers:

```toml
[mcp_servers.my-skill-http]
url = "https://api.example.com/mcp"
bearer_token_env_var = "MY_SKILL_API_TOKEN"
enabled_tools = ["query"]
```

All fields map directly to the Codex config schema. ([GitHub][1])

---

## 5. Extending `skill-porter` Core (hi-ai “Plan” + “Implement” phases)

### 5.1 Extend `PLATFORM_TYPES` and `PlatformDetector`

In `src/analyzers/detector.js` you already have:

```js
export const PLATFORM_TYPES = {
  CLAUDE: 'claude',
  GEMINI: 'gemini',
  UNIVERSAL: 'universal',
  UNKNOWN: 'unknown'
};
```

Extend to:

```js
export const PLATFORM_TYPES = {
  CLAUDE: 'claude',
  GEMINI: 'gemini',
  CODEX: 'codex',
  UNIVERSAL: 'universal',
  UNKNOWN: 'unknown'
};
```

Add Codex file detection:

* Track `files.codex` and `metadata.codex` similar to `claude`/`gemini`.
* Implement `_detectCodexFiles(dirPath)`:

  * Look for:

    * `codex-plugin.toml`
    * `CODEX_AGENTS.md` or `AGENTS.md`
    * `codex-config.snippet.toml`
  * Parse `codex-plugin.toml` for `plugin.id`, `plugin.description`, etc., and stash into `metadata.codex`.

Update `detect()` to:

* Call `_detectCodexFiles`.
* Decide platform:

  * Claude + Gemini + Codex → `UNIVERSAL`
  * Any two of the three → still `UNIVERSAL` (high confidence).
  * Only Codex → `CODEX`.

Extend `analyze` CLI output to print `Codex files found:` and Codex metadata exactly as it does for Claude and Gemini.

### 5.2 Extend `Validator` with Codex rules

In `src/analyzers/validator.js`, add CODEX logic alongside Claude and Gemini:

```js
if (platform === PLATFORM_TYPES.CODEX || platform === PLATFORM_TYPES.UNIVERSAL) {
  await this._validateCodex(dirPath);
}
```

Implement `_validateCodex(dirPath)`:

Checks:

1. `codex-plugin.toml` exists; parse TOML (reuse your YAML/TOML helpers).
2. Required fields under `[plugin]`: `id`, `display_name`, `description`, `version`.

   * Enforce slug format on `id` (lowercase letters, digits, hyphens).
   * Enforce length constraints similar to Claude’s `name` rules.
3. `CODEX_AGENTS.md` exists.

   * Optional: ensure non-empty content, and description length threshold.
4. `codex-config.snippet.toml` exists and contains at least one `[mcp_servers.*]` table.

   * Optional: warn if no MCP servers but plugin claims `uses_mcp`.

Return structure same as existing validation: `{ valid, errors, warnings }`.

### 5.3 Extend `SkillPorter` API

In `src/index.js` you currently route only between Claude and Gemini.

You need:

* New converter classes:

  * `ClaudeToCodexConverter`
  * `GeminiToCodexConverter`
  * Optionally `CodexToClaudeConverter`, `CodexToGeminiConverter`.

Add imports:

```js
import { ClaudeToCodexConverter } from './converters/claude-to-codex.js';
import { GeminiToCodexConverter } from './converters/gemini-to-codex.js';
import { CodexToClaudeConverter } from './converters/codex-to-claude.js';
import { CodexToGeminiConverter } from './converters/codex-to-gemini.js';
```

Update `convert()`:

* Allow `targetPlatform` to be `'codex'`.
* Switch logic:

  ```js
  if (targetPlatform === PLATFORM_TYPES.GEMINI) {
    if (detection.platform === PLATFORM_TYPES.CLAUDE) {
      converter = new ClaudeToGeminiConverter(sourcePath, outputPath);
    } else if (detection.platform === PLATFORM_TYPES.CODEX) {
      converter = new CodexToGeminiConverter(sourcePath, outputPath);
    }
  } else if (targetPlatform === PLATFORM_TYPES.CLAUDE) {
    if (detection.platform === PLATFORM_TYPES.GEMINI) {
      converter = new GeminiToClaudeConverter(sourcePath, outputPath);
    } else if (detection.platform === PLATFORM_TYPES.CODEX) {
      converter = new CodexToClaudeConverter(sourcePath, outputPath);
    }
  } else if (targetPlatform === PLATFORM_TYPES.CODEX) {
    if (detection.platform === PLATFORM_TYPES.CLAUDE) {
      converter = new ClaudeToCodexConverter(sourcePath, outputPath);
    } else if (detection.platform === PLATFORM_TYPES.GEMINI) {
      converter = new GeminiToCodexConverter(sourcePath, outputPath);
    }
  } else {
    throw new Error(`Invalid target platform: ${targetPlatform}. Must be 'claude', 'gemini', or 'codex'`);
  }
  ```

### 5.4 Extend CLI interface

In `src/cli.js`:

* Extend `--to` option help text to mention `codex` and change default only if you want.

  ```js
  .option('-t, --to <platform>', 'Target platform (claude, gemini, or codex)', 'gemini')
  ```

* When printing “Next steps”, add Codex branch:

  ```js
  if (targetPlatform === PLATFORM_TYPES.GEMINI) {
    console.log(chalk.gray(`  gemini extensions install ${options.output || sourcePath}`));
  } else if (targetPlatform === PLATFORM_TYPES.CLAUDE) {
    console.log(chalk.gray(`  cp -r ${options.output || sourcePath} ~/.claude/skills/`));
  } else if (targetPlatform === PLATFORM_TYPES.CODEX) {
    console.log(chalk.gray(`  cat ${path.join(options.output || sourcePath, 'codex-config.snippet.toml')} >> ~/.codex/config.toml`));
    console.log(chalk.gray(`  # Optionally merge CODEX_AGENTS.md into your AGENTS.md or add it to project_doc_fallback_filenames.`));
  }
  ```

* Extend `validate` and `analyze` commands to surface `codex` metadata; this is trivial once `PlatformDetector` and `Validator` support it.

### 5.5 Update `makeUniversal` semantics

Current implementation only handles Claude/Gemini.

Change approach:

* Use full detection result instead of just `detection.platform`.
* Algo:

  ```js
  const detection = await this.detector.detect(sourcePath);

  const haveClaude = detection.files.claude.length > 0;
  const haveGemini = detection.files.gemini.length > 0;
  const haveCodex  = detection.files.codex?.length > 0;

  const targets = [];
  if (!haveClaude) targets.push(PLATFORM_TYPES.CLAUDE);
  if (!haveGemini) targets.push(PLATFORM_TYPES.GEMINI);
  if (!haveCodex)  targets.push(PLATFORM_TYPES.CODEX);

  for (const target of targets) {
    await this.convert(sourcePath, target, { outputPath, validate: true });
  }

  result.platform = PLATFORM_TYPES.UNIVERSAL;
  result.message  = 'Successfully created universal skill/extension for Claude, Gemini, and Codex';
  ```

Now “universal” really means all three CLIs.

### 5.6 Optional features

* `ForkSetup`:

  * Extend `_ensureDualPlatform` to `_ensureUniversal` and include Codex:

    * Check for `codex-plugin.toml`.
    * If missing, run `porter.convert(forkPath, 'codex', { validate: true })`.
  * Extend `_setupInstallations`:

    * Add a `codex` entry containing text instructions:

      ```js
      installations.codex = 'Append codex-config.snippet.toml to ~/.codex/config.toml and restart Codex';
      ```

* `PRGenerator`:

  * Update commit message/PR text to mention Codex when target is `codex`, similar to existing Claude/Gemini messaging.

---

## 6. Converter Logic Details

### 6.1 Claude → Codex (`ClaudeToCodexConverter`)

Structure it like existing `ClaudeToGeminiConverter`.

Steps:

1. Extract metadata from `SKILL.md`:

   * Parse YAML frontmatter: `name`, `description`, `allowed-tools`, `subagents`, etc.
   * Extract body content and any environment-variable related sections.
2. Build `codex-plugin.toml`:

   * Map `frontmatter.name` → `plugin.id` (normalized) and `display_name`.
   * Map `frontmatter.description` → `plugin.description`.
   * Optional: infer `uses_mcp`, `runs_shell`, etc., based on allowed tools and content.
3. Generate `CODEX_AGENTS.md`:

   * Title line with skill name.
   * Description paragraph.
   * Convert the main body of `SKILL.md` into an agent instruction doc (strip conversion footers, same pattern as Gemini converter).
4. Generate `codex-config.snippet.toml`:

   * Take any MCP configuration from Claude side (SkillPorter already knows how to transform MCP server configurations between Claude and Gemini; reuse that metadata and map it to `[mcp_servers.*]` as shown in Codex docs).
   * For each server:

     * If original was STDIO → use `command`/`args`/`cwd`/`env`/`env_vars`.
     * If original was HTTP → use `url`, `bearer_token_env_var`, `http_headers`, `env_http_headers`.
5. Inject `docs/CODEX_ARCHITECTURE.md`:

   * Follow pattern from `_injectDocs()` in `ClaudeToGeminiConverter`, but with Codex-specific content.

Return structure matches other converters: `{ success, files, warnings, errors, metadata }`.

### 6.2 Gemini → Codex (`GeminiToCodexConverter`)

Mirror your existing `GeminiToClaudeConverter`.

Steps:

1. Read `gemini-extension.json`:

   * Extract `name`, `description`, `version`, `settings`, `mcpServers`, `excludeTools`.
2. Generate `codex-plugin.toml`:

   * Map `name`/`description`/`version`.
   * Use `settings` (env vars) to set up hints in `[plugin.capabilities]` or comments.
3. Generate `CODEX_AGENTS.md` from `GEMINI.md`:

   * Strip Gemini-specific headers (“Gemini CLI Extension”, “Quick Start”).
   * Replace with Codex heading and description as in Claude→Codex path.
4. Generate `codex-config.snippet.toml`:

   * Use `mcpServers` block in Gemini manifest and map to `[mcp_servers.*]` identical to Claude→Codex.
   * If Gemini `excludeTools` exists, convert to Codex MCP `enabled_tools`/`disabled_tools`:

     * You already have a mapping function that knows the full tool universe when converting `excludeTools` ↔ `allowed-tools`. Reuse that list and decide which tools to expose in Codex configuration.

### 6.3 Codex → Claude/Gemini (optional but clean)

Later, implement:

* `CodexToClaudeConverter`:

  * Inverse of above: parse `codex-plugin.toml`, `CODEX_AGENTS.md`, and `codex-config.snippet.toml`.
  * Generate `SKILL.md`, `.claude-plugin/marketplace.json`, `.claude/commands/`, MCP config.
* `CodexToGeminiConverter`:

  * Generate `gemini-extension.json`, `GEMINI.md`, `commands/*.toml`, MCP config from Codex snippet and agents instructions.

This will allow:

```bash
skill-porter convert . --to claude
skill-porter convert . --to gemini
skill-porter convert . --to codex
```

from any starting platform.

---

## 7. How a User Actually Uses It Once Implemented

No soft guidance, just the final flows:

### 7.1 Starting from a Claude Skill

```bash
# in a repo with SKILL.md
skill-porter convert . --to codex
```

Result:

* `codex-plugin.toml`
* `CODEX_AGENTS.md`
* `codex-config.snippet.toml`
* `docs/CODEX_ARCHITECTURE.md`

Then:

```bash
cat codex-config.snippet.toml >> ~/.codex/config.toml
# Option A: copy CODEX_AGENTS.md into AGENTS.md in the repo
# Option B: add CODEX_AGENTS.md to project_doc_fallback_filenames in ~/.codex/config.toml
```

### 7.2 Making a repo truly “universal”

```bash
skill-porter universal .
```

After the changes above this ensures:

* Claude skill files present and valid.
* Gemini extension files present and valid.
* Codex plugin files present and valid.

Install on all three CLIs using the printed instructions from the CLI.

---

## 8. Boundary Clarification

* You do not need to modify Codex core to get value:

  * The plugin format is just files; users can manually merge the config snippet and docs.
* To get a full “plugin manager” feel identical to Claude Code:

  * Implement a thin `codex-plugins` helper CLI *outside* Codex that:

    * Copies plugin dirs into `~/.codex/plugins/<id>/`.
    * Appends `codex-config.snippet.toml` to `~/.codex/config.toml` (idempotently).
    * Optionally merges `CODEX_AGENTS.md` into project `AGENTS.md`.

`skill-porter` then becomes the universal compiler into this format across Claude Code, Gemini CLI, and Codex CLI.

[1]: https://raw.githubusercontent.com/openai/codex/main/docs/config.md "raw.githubusercontent.com"
[2]: https://docs.claude.com/en/docs/claude-code/skills?utm_source=chatgpt.com "Agent Skills - Claude Docs"
